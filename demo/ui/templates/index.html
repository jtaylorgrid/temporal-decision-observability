<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Observability - Temporal + XTDB</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #f8f7f5;
            --card-bg: #ffffff;
            --border: #e5e5e5;
            --text: #1a1a1a;
            --text-muted: #4a4a4a;
            --accent: #ffb800;
            --accent-hover: #f7931d;
            --success: #28a745;
            --warning: #f7931d;
            --danger: #dc3545;
            --dark: #2c2f32;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Fira Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 24px 20px; }
        .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .logo { height: 24px; opacity: 0.8; }
        .logo:hover { opacity: 1; }
        h1 { color: var(--dark); margin-bottom: 0; font-weight: 700; font-size: 1.6em; }
        h2 { color: var(--text); margin: 20px 0 10px; font-size: 1.2em; font-weight: 600; }
        .subtitle { color: var(--text-muted); margin-bottom: 28px; font-size: 0.95em; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
        }
        .card h3 {
            color: var(--dark);
            margin-bottom: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1.1em;
        }
        .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 25px; }
        .stat {
            text-align: center;
            padding: 24px 20px;
            background: var(--card-bg);
            border-radius: 10px;
            border: 1px solid var(--border);
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
            position: relative;
            overflow: hidden;
        }
        .stat::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--accent);
        }
        .stat-value { font-size: 2.5em; font-weight: 700; color: var(--dark); line-height: 1.1; }
        .stat-label { font-size: 0.85em; color: var(--text-muted); font-weight: 500; margin-top: 8px; }
        .stat.danger::before { background: var(--danger); }
        .stat.danger .stat-value { color: var(--danger); }
        .stat.warning::before { background: var(--warning); }
        .stat.warning .stat-value { color: var(--warning); }
        .stat.success::before { background: var(--success); }
        .stat.success .stat-value { color: var(--success); }
        table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        th, td { padding: 14px 12px; text-align: left; border-bottom: 1px solid var(--border); }
        th { color: var(--text-muted); font-weight: 600; text-transform: uppercase; font-size: 0.75em; letter-spacing: 0.5px; background: var(--bg); }
        tbody tr { transition: background 0.15s; }
        tbody tr:hover { background: rgba(255, 184, 0, 0.08); }
        td { font-variant-numeric: tabular-nums; }
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .badge-high { background: var(--danger); color: white; }
        .badge-medium { background: var(--warning); color: white; }
        .badge-low { background: var(--success); color: white; }
        .badge-churned { background: var(--danger); color: white; }
        .badge-retained { background: var(--success); color: white; }
        .text-mono { font-family: 'Fira Mono', 'Consolas', monospace; font-size: 0.9em; }
        .text-muted { color: var(--text-muted); }
        .timeline {
            position: relative;
            padding-left: 30px;
            max-height: 400px;
            overflow-y: auto;
        }
        .timeline::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border);
        }
        .timeline-item {
            position: relative;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -24px;
            top: 17px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid var(--card-bg);
            box-shadow: 0 0 0 2px var(--accent);
        }
        .timeline-item.churn_prediction::before { background: var(--warning); box-shadow: 0 0 0 2px var(--warning); }
        .timeline-item.outcome::before { background: var(--danger); box-shadow: 0 0 0 2px var(--danger); }
        .timeline-time { font-size: 0.8em; color: var(--text-muted); }
        .timeline-source { font-size: 0.75em; color: var(--dark); text-transform: uppercase; font-weight: 600; background: var(--accent); padding: 2px 8px; border-radius: 10px; display: inline-block; }
        .timeline-item.churn_prediction .timeline-source { background: rgba(247, 147, 29, 0.2); color: var(--warning); }
        .timeline-item.outcome .timeline-source { background: rgba(220, 53, 69, 0.15); color: var(--danger); }
        .timeline-desc { margin-top: 8px; }
        .btn {
            background: var(--accent);
            color: var(--dark);
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: background 0.2s;
        }
        .btn:hover { background: var(--accent-hover); }
        .tabs { display: flex; gap: 10px; margin-bottom: 24px; flex-wrap: wrap; }
        .tab {
            padding: 11px 22px;
            background: var(--card-bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            color: var(--text-muted);
            font-weight: 500;
            font-size: 0.92em;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        .tab:hover { border-color: var(--accent); color: var(--dark); background: rgba(255, 184, 0, 0.05); }
        .tab.active { background: var(--accent); color: var(--dark); border-color: var(--accent); font-weight: 600; box-shadow: 0 2px 8px rgba(255, 184, 0, 0.3); }
        .query-box {
            background: #1e2127;
            border: none;
            border-radius: 8px;
            padding: 18px 20px;
            font-family: 'Fira Mono', 'Consolas', monospace;
            font-size: 0.82em;
            overflow-x: auto;
            white-space: pre;
            color: #abb2bf;
            margin-bottom: 18px;
            line-height: 1.6;
        }
        .query-box code { color: var(--accent); }
        .loading { text-align: center; padding: 50px 40px; color: var(--text-muted); font-size: 0.95em; }
        .empty-state { text-align: center; padding: 40px; color: var(--text-muted); background: var(--bg); border-radius: 8px; }

        /* Demo Script Styles */
        .script-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 0.75em;
            color: var(--dark);
            cursor: pointer;
            z-index: 1000;
            padding: 8px 12px;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            font-weight: 600;
            opacity: 0.9;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .script-toggle:hover { opacity: 1; transform: translateY(-1px); }
        .script-overlay {
            display: none;
            position: fixed;
            top: 0;
            right: 0;
            width: 420px;
            height: 100vh;
            background: var(--card-bg);
            border-left: 3px solid var(--accent);
            z-index: 999;
            overflow-y: auto;
            box-shadow: -4px 0 20px rgba(0,0,0,0.15);
        }
        .script-overlay.visible { display: block; }
        .script-header {
            position: sticky;
            top: 0;
            background: var(--dark);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .script-header h2 { margin: 0; color: var(--accent); font-size: 1.1em; font-weight: 600; }
        .script-close {
            background: none;
            border: none;
            color: rgba(255,255,255,0.7);
            font-size: 1.5em;
            cursor: pointer;
            padding: 0 8px;
        }
        .script-close:hover { color: #fff; }
        .script-content { padding: 20px; }
        .script-section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        .script-section:last-child { border-bottom: none; }
        .script-section h3 {
            color: var(--dark);
            font-size: 0.95em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        .script-section h3 .step-num {
            background: var(--accent);
            color: var(--dark);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            flex-shrink: 0;
            font-weight: 700;
        }
        .script-section p, .script-section li {
            font-size: 0.85em;
            line-height: 1.7;
            color: var(--text);
            margin-bottom: 10px;
        }
        .script-section ul { padding-left: 20px; margin: 10px 0; }
        .script-section li { margin-bottom: 6px; }
        .script-action {
            background: rgba(255, 184, 0, 0.15);
            border-left: 3px solid var(--accent);
            padding: 10px 12px;
            margin: 12px 0;
            font-size: 0.8em;
            border-radius: 0 4px 4px 0;
        }
        .script-action strong { color: var(--dark); }
        .script-quote {
            background: var(--bg);
            border-left: 3px solid var(--warning);
            padding: 10px 12px;
            margin: 12px 0;
            font-size: 0.8em;
            font-style: italic;
            color: var(--text-muted);
            border-radius: 0 4px 4px 0;
        }
        .script-quote cite {
            display: block;
            margin-top: 6px;
            font-style: normal;
            color: var(--warning);
            font-size: 0.9em;
            font-weight: 600;
        }
        .script-pain {
            background: rgba(220, 53, 69, 0.08);
            border-left: 3px solid var(--danger);
            padding: 10px 12px;
            margin: 12px 0;
            font-size: 0.8em;
            border-radius: 0 4px 4px 0;
        }
        .script-solution {
            background: rgba(40, 167, 69, 0.08);
            border-left: 3px solid var(--success);
            padding: 10px 12px;
            margin: 12px 0;
            font-size: 0.8em;
            border-radius: 0 4px 4px 0;
        }
        .key-point {
            color: var(--accent-hover);
            font-weight: 600;
        }
        .script-toc {
            background: var(--bg);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .script-toc h4 {
            font-size: 0.8em;
            color: var(--text-muted);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        .script-toc a {
            display: block;
            color: var(--dark);
            text-decoration: none;
            font-size: 0.85em;
            padding: 4px 0;
            font-weight: 500;
        }
        .script-toc a:hover { color: var(--accent-hover); }
    </style>
</head>
<body>
    <!-- Demo Script Toggle -->
    <div class="script-toggle" onclick="toggleScript()" title="Press 's' to toggle">
        Script [S]
    </div>

    <!-- Demo Script Overlay -->
    <div class="script-overlay" id="scriptOverlay">
        <div class="script-header">
            <h2>Demo Talk Track</h2>
            <button class="script-close" onclick="toggleScript()">&times;</button>
        </div>
        <div class="script-content">
            <div class="script-toc">
                <h4>Sections</h4>
                <a href="#why-temporal">0. Why Temporal?</a>
                <a href="#intro">1. Introduction & Problem</a>
                <a href="#demo">2. Live Demo Walkthrough</a>
                <a href="#activity-context-demo">3. Activity Decision Context</a>
                <a href="#corrections-demo">4. Before/After Corrections</a>
                <a href="#pain">5. Temporal's Audit Limitations</a>
                <a href="#solution">6. Why XTDB</a>
                <a href="#close">7. Closing</a>
                <hr style="border-color: var(--border); margin: 8px 0;">
                <a href="#activity-context-demo" style="color: var(--success);">NEW: Direct Activity Writes</a>
            </div>

            <!-- SECTION 0: WHY TEMPORAL -->
            <div class="script-section" id="why-temporal">
                <h3><span class="step-num">0</span> Why Temporal?</h3>

                <p><strong>Context-setting (if audience is new to Temporal):</strong></p>

                <p>"Before we dive into the demo, let me quickly explain why we're using Temporal for agent orchestration."</p>

                <div class="script-solution">
                    <strong>Key insight:</strong> "The big advantage is that <span class="key-point">developers just build to the happy path</span>. You write your workflow as if nothing will fail, and Temporal handles retries, timeouts, and crash recovery automatically."
                </div>

                <p>"Traditional systems require defensive coding everywhere &mdash; retry logic, state machines, idempotency checks. With Temporal, you write <code>workflow.Execute(activity)</code> and trust the platform."</p>

                <div class="script-solution">
                    <strong>Durability guarantee:</strong> "Temporal gives you <span class="key-point">guarantees for getting into a known state</span>. Every workflow reaches a definitive end &mdash; completed, failed, or timed out. No more 'is it still running?' uncertainty."
                </div>

                <p>"If a process crashes, a server restarts, or there's a network partition &mdash; workflows resume exactly where they left off. State is durably persisted at every step."</p>

                <div class="script-action">
                    <strong>Transition:</strong> "So Temporal is great at orchestration and durability. But it wasn't designed to be a long-term audit database. That's where XTDB comes in. Let me show you the problem..."
                </div>
            </div>

            <!-- SECTION 1: INTRODUCTION -->
            <div class="script-section" id="intro">
                <h3><span class="step-num">1</span> Introduction & Problem</h3>

                <p><strong>Opening (while stats are visible):</strong></p>

                <p>"Today I want to show you something we've been working on around <span class="key-point">decision observability</span> for AI agent orchestration."</p>

                <div class="script-action">
                    <strong>Action:</strong> Point to the three stat boxes at the top
                </div>

                <p>"What you're looking at is a customer service AI agent orchestrated by Temporal. It analyzes tickets, looks up customer profiles, checks churn risk signals, and routes to the appropriate queue."</p>

                <p>"But here's the problem: <span class="key-point">the ML model predictions have propagation lag</span>. By the time a customer is flagged as high-risk in one system, they may have already been routed to the wrong queue."</p>

                <p>"This creates a compliance nightmare. When a regulator asks <em>'what did your AI know when it made that decision?'</em> — you need to answer that with precision."</p>
            </div>

            <!-- SECTION 2: LIVE DEMO -->
            <div class="script-section" id="demo">
                <h3><span class="step-num">2</span> Live Demo Walkthrough</h3>

                <p><strong>Audit Tab (default view):</strong></p>

                <div class="script-action">
                    <strong>Action:</strong> Ensure "Audit: Misrouted Customers" tab is active. Point to the SQL query box.
                </div>

                <p>"This is a <span class="key-point">bitemporal query</span>. Notice the <code>FOR VALID_TIME AS OF</code> clause — this asks XTDB: what churn predictions were valid at the exact moment this routing decision was made?"</p>

                <div class="script-action">
                    <strong>Action:</strong> Point to the table rows, especially the "Lag" column
                </div>

                <p>"Look at this customer — they were flagged as 95% churn risk <em>45 minutes before</em> the routing decision. The information existed. Our agent just didn't have access to it in time."</p>

                <p>"That's 5 customers who should have gone to the priority queue. These aren't hypotheticals — this is what <em>was known</em> at decision time."</p>

                <div class="script-action">
                    <strong>Action:</strong> Click the "Counterfactual Analysis" tab
                </div>

                <p><strong>Counterfactual Tab:</strong></p>

                <p>"Now let's see what actually happened to these customers. Click 'Counterfactual Analysis'."</p>

                <div class="script-action">
                    <strong>Action:</strong> Point to the churned/retained stats and the $21K lost LTV
                </div>

                <p>"Every single high-risk customer churned. That's <span class="key-point">$21,000 in lost lifetime value</span> from customers we <em>could have</em> prioritized."</p>

                <p>"This is the counterfactual: if our agent had the real-time data, we could have intervened. This query joins churn predictions with actual outcomes — something that requires keeping both datasets with their temporal context."</p>

                <div class="script-action">
                    <strong>Action:</strong> Click the "Event Timeline" tab
                </div>

                <p><strong>Timeline Tab:</strong></p>

                <p>"This is the unified timeline. <span class="key-point">Three different data sources</span> — Temporal workflow events, ML model predictions, and customer outcomes — all queryable together."</p>

                <div class="script-action">
                    <strong>Action:</strong> Scroll the timeline slowly. Point out the different colored dots.
                </div>

                <p>"Blue dots are workflow events from Temporal. Yellow are churn predictions. Red are actual churn outcomes. All ordered by <em>when they really happened</em>, not when we recorded them."</p>

                <p>"This is what regulators want to see. A complete audit trail across all your systems."</p>

                <div class="script-action">
                    <strong>Action:</strong> Click the "Workflow Events" tab
                </div>

                <p><strong>Workflow Events Tab:</strong></p>

                <p>"Now here's something new — we've added <span class="key-point">full payload capture</span>. Select any workflow and you can see every event with its complete data."</p>

                <div class="script-action">
                    <strong>Action:</strong> Select a workflow from the dropdown. Click on an ActivityTaskScheduled or ActivityTaskCompleted event to expand it.
                </div>

                <p>"Look at this activity — you can see the full <code>activity_input</code> with the Ticket details, customer Profile, Sentiment analysis, Churn risk, and Routing decision. This is the exact data the AI agent used to make its decision."</p>

                <p>"For compliance, this is critical: <em>'what inputs did the agent receive?'</em> and <em>'what was the output?'</em> — now you have answers with the precise data, not just event types."</p>
            </div>

            <!-- SECTION 3: ACTIVITY DECISION CONTEXT -->
            <div class="script-section" id="activity-context-demo">
                <h3><span class="step-num">3</span> Activity Decision Context</h3>

                <p>"Now let me show you something that goes beyond CDC. Click the 'Activity Context' tab."</p>

                <div class="script-action">
                    <strong>Action:</strong> Click the "Activity Context" tab
                </div>

                <p>"We have <span class="key-point">two ways to capture decision data</span>:"</p>

                <ul>
                    <li><strong>CDC via Kafka Connect</strong> &mdash; streams Temporal events automatically. Captures <em>what the workflow did</em>.</li>
                    <li><strong>Direct Activity Writes</strong> &mdash; activities call <code>xtdb.Save(ctx)</code> explicitly. Captures <em>what external systems believed</em> at the exact moment a decision was made.</li>
                </ul>

                <div class="script-action">
                    <strong>Action:</strong> Point to the two tables: Churn Signals and Routing Decisions
                </div>

                <p>"On the left, you see <code>activity_churn_signals</code> &mdash; these are the churn scores the activity received from the ML model at decision time. On the right, <code>activity_routing_decisions</code> &mdash; the full context that informed each routing decision: sentiment, urgency, customer tier, LTV."</p>

                <div class="script-solution">
                    <strong>Key insight:</strong> CDC captures workflow structure. Direct writes capture the <em>external state</em> &mdash; ML predictions, CRM data, anything the activity consulted. Together, they answer: "what did the agent do?" <em>and</em> "what did it know?"
                </div>

                <p>"For compliance, this is critical. You can now prove not just the decision, but the complete context that informed it."</p>
            </div>

            <!-- SECTION 4: BEFORE/AFTER CORRECTIONS -->
            <div class="script-section" id="corrections-demo">
                <h3><span class="step-num">4</span> Before/After Corrections</h3>

                <p>"Now let me show you something that really demonstrates why bitemporality matters."</p>

                <div class="script-action">
                    <strong>Action:</strong> Click the "Before/After Corrections" tab
                </div>

                <p>"We've simulated a real-world scenario: an ML model correction arrives after decisions have already been made. Three customers &mdash; CUST-002, CUST-006, and CUST-010 &mdash; were originally scored as low or medium risk. The corrected model says they were actually high risk."</p>

                <p>"The key SQL here is <code>SETTING DEFAULT SYSTEM_TIME TO AS OF</code>. This tells XTDB: <span class="key-point">show me the database as it was before the corrections arrived</span>. Not a backup. Not a snapshot. The actual live database, time-traveled."</p>

                <div class="script-action">
                    <strong>Action:</strong> Point to the "Before Corrections" panel on the left
                </div>

                <p>"On the left: what the audit query returned <em>before</em> corrections. These are the customers we already knew about."</p>

                <div class="script-action">
                    <strong>Action:</strong> Point to the "After Corrections" panel on the right, then the "Newly Detected" section
                </div>

                <p>"On the right: the same query, same data, but <em>now</em>. Three new customers appear. They were invisible to the audit before the model correction."</p>

                <p>"Think about what this means for compliance: <span class="key-point">without bitemporality, the corrections would overwrite the original scores</span>. You'd never know these customers were missed. With XTDB, both the before and after states are preserved — permanently."</p>

                <div class="script-solution">
                    <strong>Takeaway:</strong> This is the difference between "we fixed our model" and "we can prove exactly what changed and when." Regulators care about both.
                </div>
            </div>

            <!-- SECTION 5: TEMPORAL'S LIMITATIONS -->
            <div class="script-section" id="pain">
                <h3><span class="step-num">5</span> Temporal's Audit Limitations</h3>

                <p>"Now, you might ask — can't Temporal do this natively? Let me share what we're hearing from the community."</p>

                <p><strong>Pain Point 1: Retention Limits</strong></p>

                <div class="script-quote">
                    "I run a financial application, and I rely on querying the completed workflows. As Temporal deletes the completed workflows, it's a big problem for my application."
                    <cite>— Temporal Community Forum</cite>
                </div>

                <div class="script-quote">
                    "The 90-day retention window has been a real issue for us."
                    <cite>— Betashares (financial services)</cite>
                </div>

                <div class="script-pain">
                    <strong>The problem:</strong> Temporal Cloud offers 30-90 days retention. HIPAA requires 6 years. SOX requires 7 years. There's a massive gap.
                </div>

                <p><strong>Pain Point 2: Querying is Hard</strong></p>

                <div class="script-quote">
                    "I have a workflow tracking the state of a payment... What's the best way to find out how many payments are currently pending?"
                    <cite>— Temporal Community Forum</cite>
                </div>

                <div class="script-quote">
                    "We tried querying Cassandra directly, but it seems it serialized into a thrift binary object."
                    <cite>— User attempting direct DB access</cite>
                </div>

                <div class="script-pain">
                    <strong>The problem:</strong> The Visibility API has limits. Direct DB queries hit serialized blobs. Users are stuck.
                </div>

                <p><strong>Pain Point 3: Audit Gaps</strong></p>

                <div class="script-quote">
                    "Audit Logs do NOT capture data plane events, like Workflow Start, Workflow Terminate, Schedule Create, etc."
                    <cite>— Temporal Documentation</cite>
                </div>

                <div class="script-pain">
                    <strong>The problem:</strong> Temporal's audit logs cover the control plane (who logged in), not the data plane (what decisions were made). For compliance, you need both.
                </div>

                <p><strong>Pain Point 4: Export Pipeline Complexity</strong></p>

                <div class="script-quote">
                    "Convert protos to another format to perform analytics... upload into your data store: Athena, Redshift, Snowflake or Databricks."
                    <cite>— Temporal Documentation</cite>
                </div>

                <div class="script-quote">
                    "Export has 'at least once' guarantee. Please dedupe based on runID. Schema of Parquet files may change."
                    <cite>— Temporal Export Caveats</cite>
                </div>

                <div class="script-pain">
                    <strong>The problem:</strong> The official answer is a complex ETL pipeline with deduplication, schema evolution, and data warehouse integration. That's months of engineering.
                </div>
            </div>

            <!-- SECTION 6: WHY XTDB -->
            <div class="script-section" id="solution">
                <h3><span class="step-num">6</span> Why XTDB Solves This</h3>

                <p>"XTDB is a bitemporal database. That means every record tracks two timelines:"</p>

                <ul>
                    <li><strong>Valid Time</strong> (<code>_valid_from</code>): When was this fact true in the real world?</li>
                    <li><strong>System Time</strong> (<code>_system_from</code>): When did we record it?</li>
                </ul>

                <div class="script-solution">
                    <strong>Benefit 1:</strong> Point-in-time queries are native. <code>FOR VALID_TIME AS OF timestamp</code> is first-class SQL syntax, not a workaround.
                </div>

                <div class="script-solution">
                    <strong>Benefit 2:</strong> Unlimited retention. Keep data for 7+ years without complex archival pipelines.
                </div>

                <div class="script-solution">
                    <strong>Benefit 3:</strong> Join across sources. Temporal events, ML predictions, CRM data — all in one query.
                </div>

                <div class="script-solution">
                    <strong>Benefit 4:</strong> PostgreSQL wire protocol. Your existing tools (psql, Metabase, dbt) just work.
                </div>

                <p>"What we've built here is a <span class="key-point">CDC connector</span> that streams Temporal workflow events into XTDB in real-time. No batch ETL. No schema conversion. Just SQL."</p>

                <div class="script-action">
                    <strong>Action:</strong> Point back to the Audit tab
                </div>

                <p>"That query you saw? It's running against live data. The workflows completed seconds ago. The churn predictions came from a different system. And we're joining them with precise temporal semantics."</p>
            </div>

            <!-- SECTION 7: CLOSING -->
            <div class="script-section" id="close">
                <h3><span class="step-num">7</span> Closing</h3>

                <p><strong>Summary:</strong></p>

                <p>"If you're using Temporal for AI agent orchestration — or any workflow where decisions matter — you're going to face these questions:"</p>

                <ul>
                    <li>What did the agent know when it made that decision?</li>
                    <li>What <em>should</em> it have known?</li>
                    <li>Can we prove this to a regulator in 3 years?</li>
                </ul>

                <p>"Temporal is great at orchestration. But it wasn't designed to be an audit database. <span class="key-point">XTDB fills that gap.</span>"</p>

                <p><strong>Call to Action:</strong></p>

                <p>"We're looking for design partners who are building AI agents with Temporal and need compliance-grade observability. If that's you, let's talk about what your audit requirements look like."</p>

                <div class="script-action">
                    <strong>Action:</strong> Open for Q&A. Common questions below.
                </div>

                <p><strong>Anticipated Questions:</strong></p>

                <ul>
                    <li><em>"What's the latency?"</em> — Sub-second. CDC connector polls every 10s by default, configurable.</li>
                    <li><em>"How much data can it handle?"</em> — XTDB scales horizontally. We've tested millions of events.</li>
                    <li><em>"Does it work with Temporal Cloud?"</em> — Yes, uses the standard gRPC API.</li>
                    <li><em>"What about other workflow engines?"</em> — The pattern applies. We're starting with Temporal because that's where the demand is.</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>Decision Observability for Agentic Systems</h1>
            <img src="https://cdn.brandfetch.io/idyloU541m/theme/dark/logo.svg?c=1bxid64Mup7aczewSAYMX&t=1729658573277" alt="Grid Dynamics" class="logo">
        </div>
        <p class="subtitle">Bitemporal audit of AI agent decisions using Temporal + XTDB</p>

        <div class="stat-grid">
            <div class="stat" id="stat-workflows">
                <div class="stat-value">-</div>
                <div class="stat-label">Workflows Processed</div>
            </div>
            <div class="stat danger" id="stat-misrouted">
                <div class="stat-value">-</div>
                <div class="stat-label">Misrouted (High Churn Risk)</div>
            </div>
            <div class="stat warning" id="stat-lost-ltv">
                <div class="stat-value">-</div>
                <div class="stat-label">Lost LTV from Churned</div>
            </div>
        </div>

        <div class="tabs">
            <div class="tab active" data-tab="intro">Introduction</div>
            <div class="tab" data-tab="audit">Audit: Misrouted Customers</div>
            <div class="tab" data-tab="counterfactual">Counterfactual Analysis</div>
            <div class="tab" data-tab="timeline">Event Timeline</div>
            <div class="tab" data-tab="corrections">Before/After Corrections</div>
            <div class="tab" data-tab="events">Workflow Events</div>
            <div class="tab" data-tab="activity-context">Activity Context</div>
            <div class="tab" data-tab="export" style="margin-left: auto; background: var(--dark); color: var(--accent);">Export Static HTML</div>
        </div>

        <div id="tab-intro" class="tab-content">
            <div class="card" style="border: 2px solid var(--accent); background: linear-gradient(135deg, var(--card-bg) 0%, #fafafa 100%);">
                <h3 style="color: var(--dark); font-size: 1.3em; margin-bottom: 1.2em;">What is Decision Observability?</h3>

                <p style="font-size: 1.05em; line-height: 1.8; margin-bottom: 1.5em; color: var(--text);">
                    <strong>Decision Observability</strong> is the ability to audit, analyze, and understand decisions made by agentic systems
                    using <span style="color: var(--accent-hover); font-weight: 600;">bitemporal data</span>. When AI agents make routing decisions,
                    process workflows, or act on ML predictions, organizations need to answer questions like:
                </p>

                <ul style="margin-left: 1.5em; margin-bottom: 1.5em; line-height: 2;">
                    <li><strong>What did the agent know</strong> when it made that decision?</li>
                    <li><strong>What should it have known</strong> if data had propagated faster?</li>
                    <li><strong>Can we prove this</strong> to a regulator in 3 years?</li>
                </ul>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin: 2em 0;">
                    <div style="background: rgba(255, 184, 0, 0.1); padding: 1.2em; border-radius: 8px; border-left: 4px solid var(--accent);">
                        <h4 style="color: var(--dark); margin-bottom: 0.5em; font-size: 0.95em;">Bitemporal Audit</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin: 0;">Query what was known at the exact time a decision was made using <code>FOR VALID_TIME AS OF</code></p>
                    </div>
                    <div style="background: rgba(247, 147, 29, 0.1); padding: 1.2em; border-radius: 8px; border-left: 4px solid var(--warning);">
                        <h4 style="color: var(--dark); margin-bottom: 0.5em; font-size: 0.95em;">Counterfactual Analysis</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin: 0;">Compare ML predictions against actual outcomes to measure decision quality</p>
                    </div>
                    <div style="background: rgba(40, 167, 69, 0.1); padding: 1.2em; border-radius: 8px; border-left: 4px solid var(--success);">
                        <h4 style="color: var(--dark); margin-bottom: 0.5em; font-size: 0.95em;">Time Travel</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin: 0;">View system state before and after corrections using <code>SETTING DEFAULT SYSTEM_TIME</code></p>
                    </div>
                    <div style="background: rgba(44, 47, 50, 0.1); padding: 1.2em; border-radius: 8px; border-left: 4px solid var(--dark);">
                        <h4 style="color: var(--dark); margin-bottom: 0.5em; font-size: 0.95em;">Full Payload Capture</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin: 0;">Inspect activity inputs, outputs, and routing decisions with complete data</p>
                    </div>
                </div>

                <h4 style="color: var(--dark); margin: 1.5em 0 1em; font-size: 1.1em;">Two Complementary Data Capture Approaches</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px;">
                    <div style="background: var(--bg); padding: 1.2em; border-radius: 8px; border: 1px solid var(--border);">
                        <h4 style="color: var(--accent-hover); margin-bottom: 0.5em; font-size: 0.95em;">1. CDC via Kafka Connect</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin-bottom: 0.8em;">Streams Temporal workflow events into XTDB automatically. Captures <em>what the workflow did</em>: event types, activity scheduling, and payloads.</p>
                        <p style="color: var(--text-muted); font-size: 0.85em; margin: 0;"><strong>Tables:</strong> <code>events</code>, <code>temporal_events</code></p>
                    </div>
                    <div style="background: var(--bg); padding: 1.2em; border-radius: 8px; border: 1px solid var(--border);">
                        <h4 style="color: var(--success); margin-bottom: 0.5em; font-size: 0.95em;">2. Direct Activity Writes</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin-bottom: 0.8em;">Activities call <code>xtdb.Save(ctx)</code> to capture decision context. Records <em>what external systems believed</em> at the exact moment a decision was made.</p>
                        <p style="color: var(--text-muted); font-size: 0.85em; margin: 0;"><strong>Tables:</strong> <code>activity_churn_signals</code>, <code>activity_routing_decisions</code></p>
                    </div>
                </div>
                <p style="color: var(--text-muted); font-size: 0.9em; margin-top: 1em; line-height: 1.7;">
                    <strong>Why both?</strong> CDC captures the workflow structure. Direct writes capture the <em>external state</em> (ML predictions, CRM data)
                    that informed decisions. Together, they answer: "what did the agent do?" <em>and</em> "what did it know?"
                </p>
            </div>

            <div class="card">
                <h3 style="color: var(--dark); margin-bottom: 1em;">Architecture</h3>
                <p style="color: var(--text-muted); margin-bottom: 1.5em; font-size: 0.95em;">
                    Data flows from multiple sources through a CDC pipeline into XTDB's bitemporal storage for analysis.
                </p>
                <div id="architecture-diagram" style="background: var(--card-bg); border-radius: 8px; overflow: hidden;">
                    <img src="/architecture.svg" alt="Decision Observability Architecture"
                         style="width: 100%; height: auto; display: block;"
                         onerror="this.parentElement.innerHTML='<p style=\'color: var(--text-muted); padding: 2em; text-align: center;\'>Architecture diagram loading...</p>'">
                </div>
            </div>

            <div class="card" style="border: 2px solid var(--accent); background: linear-gradient(135deg, var(--card-bg) 0%, #fafafa 100%);">
                <h3 style="color: var(--dark); font-size: 1.3em; margin-bottom: 1.2em;">Why Temporal for Agent Orchestration?</h3>

                <p style="font-size: 1.05em; line-height: 1.8; margin-bottom: 1.5em; color: var(--text);">
                    <strong style="color: var(--accent-hover);">Temporal</strong> is a durable execution platform that fundamentally changes how you build reliable systems.
                    The core insight: <span style="color: var(--accent-hover); font-weight: 600;">developers write code for the happy path, and Temporal handles everything else</span>.
                </p>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin: 2em 0;">
                    <div style="background: rgba(255, 184, 0, 0.1); padding: 1.2em; border-radius: 8px; border-left: 4px solid var(--accent);">
                        <h4 style="color: var(--dark); margin-bottom: 0.5em; font-size: 0.95em;">Build to the Happy Path</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin: 0;">Write your workflow as if nothing will fail. Temporal automatically retries activities, handles timeouts, and recovers from crashes. Your code stays clean and focused on business logic.</p>
                    </div>
                    <div style="background: rgba(40, 167, 69, 0.1); padding: 1.2em; border-radius: 8px; border-left: 4px solid var(--success);">
                        <h4 style="color: var(--dark); margin-bottom: 0.5em; font-size: 0.95em;">Guaranteed Known State</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin: 0;">Every workflow reaches a definitive end state &mdash; completed, failed, or timed out. No more "is it still running?" uncertainty. State is durably persisted at every step.</p>
                    </div>
                    <div style="background: rgba(247, 147, 29, 0.1); padding: 1.2em; border-radius: 8px; border-left: 4px solid var(--warning);">
                        <h4 style="color: var(--dark); margin-bottom: 0.5em; font-size: 0.95em;">Survives Everything</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin: 0;">Process crashes, server restarts, network partitions &mdash; workflows resume exactly where they left off. State is never lost. Deploy updates without losing in-flight work.</p>
                    </div>
                    <div style="background: rgba(44, 47, 50, 0.1); padding: 1.2em; border-radius: 8px; border-left: 4px solid var(--dark);">
                        <h4 style="color: var(--dark); margin-bottom: 0.5em; font-size: 0.95em;">Native Visibility</h4>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin: 0;">Query workflow state, search by custom attributes, view full event history. Built-in observability for debugging and monitoring complex multi-step processes.</p>
                    </div>
                </div>

                <div style="background: rgba(255, 184, 0, 0.15); border-left: 3px solid var(--accent); border-radius: 0 6px 6px 0; padding: 1.2em; margin-top: 1.5em;">
                    <p style="color: var(--text); font-size: 0.95em; margin: 0; line-height: 1.7;">
                        <strong style="color: var(--accent-hover);">The paradigm shift:</strong> Traditional systems require defensive coding &mdash; retry logic, state machines, idempotency checks, compensation handlers.
                        With Temporal, you write <code style="background: var(--bg); padding: 2px 6px; border-radius: 4px;">workflow.Execute(ctx, activity)</code> and trust the platform to make it happen.
                        This lets teams move faster while building more reliable systems.
                    </p>
                </div>
            </div>

            <div class="card">
                <h3 style="color: var(--dark); margin-bottom: 1em;">Demo Scenario</h3>
                <p style="color: var(--text); line-height: 1.8; margin-bottom: 1em;">
                    This demo simulates a <strong>customer service AI agent</strong> orchestrated by Temporal. The agent:
                </p>
                <ol style="margin-left: 1.5em; line-height: 2; color: var(--text);">
                    <li>Receives support tickets and analyzes customer profiles</li>
                    <li>Checks churn risk predictions from an ML model</li>
                    <li>Routes tickets to priority or standard queues based on risk</li>
                </ol>
                <p style="color: var(--text); line-height: 1.8; margin-top: 1em;">
                    The problem: <span style="color: var(--danger); font-weight: 600;">ML predictions have propagation lag</span>.
                    By the time a customer is flagged as high-risk, they may have already been routed to the wrong queue.
                    This demo shows how XTDB's bitemporal queries can identify these misrouted decisions and quantify the business impact.
                </p>

                <div style="margin-top: 1.5em; padding: 1em 1.2em; background: rgba(255, 184, 0, 0.15); border-radius: 6px; border-left: 3px solid var(--accent);">
                    <strong style="color: var(--dark);">Explore the tabs above</strong> to see bitemporal audit queries, counterfactual analysis,
                    event timelines, before/after corrections, and full workflow event payloads.
                </div>
            </div>
        </div>

        <div id="tab-audit" class="tab-content" style="display:none">
            <div class="card">
                <h3>Customers Routed to Standard Queue Despite High Churn Risk</h3>
                <div class="query-box">-- Bitemporal query: What was known at decision time?
SELECT workflow_id, decision_time, customer_id, churn_score
FROM temporal_events e
JOIN churn_predictions c
  FOR VALID_TIME AS OF e.event_time  -- Point-in-time lookup
  ON c.customer_id = ...
WHERE c.churn_score > 0.7</div>
                <div id="misrouted-results" class="loading">Loading audit results...</div>
            </div>
        </div>

        <div id="tab-counterfactual" class="tab-content" style="display:none">
            <div class="card">
                <h3>High-Risk Customers: Predicted vs Actual Outcomes</h3>
                <div class="query-box">-- Counterfactual: What actually happened to flagged customers?
SELECT customer_id, churn_score, churned, churn_reason, final_ltv
FROM churn_predictions c
JOIN customer_outcomes o ON o.customer_id = c.customer_id
WHERE c.churn_score > 0.7</div>
                <div id="counterfactual-results" class="loading">Loading counterfactual analysis...</div>
            </div>
        </div>

        <div id="tab-timeline" class="tab-content" style="display:none">
            <div class="card">
                <h3>Unified Event Timeline</h3>
                <p style="color: var(--text-muted); margin-bottom: 15px;">
                    All events from Temporal workflows, churn predictions, and customer outcomes
                    ordered by valid-time (when they occurred).
                </p>
                <div id="timeline-results" class="timeline loading">Loading timeline...</div>
            </div>
        </div>

        <div id="tab-corrections" class="tab-content" style="display:none">
            <div class="card">
                <h3>Before/After Model Corrections</h3>
                <div class="query-box">-- XTDB system-time travel: what did the database believe BEFORE corrections?
SETTING DEFAULT SYSTEM_TIME TO AS OF TIMESTAMP '&lt;pre_correction_time&gt;'
SELECT workflow_id, customer_id, churn_score, risk_level
FROM temporal_events e
JOIN churn_predictions FOR VALID_TIME ALL AS c ON ...
WHERE c.churn_score > 0.7

-- vs. current state (AFTER corrections applied)</div>
                <div id="corrections-results" class="loading">Loading before/after comparison...</div>
            </div>
        </div>

        <div id="tab-export" class="tab-content" style="display:none">
            <div class="card" style="text-align: center; padding: 3em;">
                <h3 style="margin-bottom: 1em;">Export Static HTML Report</h3>
                <p style="color: var(--text-muted); margin-bottom: 2em; max-width: 600px; margin-left: auto; margin-right: auto;">
                    Generate a fully self-contained HTML file with all current data embedded.
                    The export includes workflows, audit results, counterfactual analysis, timeline events,
                    and the architecture diagram — no server required to view.
                </p>
                <a href="/api/export" class="btn" style="display: inline-block; padding: 14px 32px; font-size: 1.1em; text-decoration: none;">
                    Download Static Export
                </a>
                <p style="color: var(--text-muted); margin-top: 1.5em; font-size: 0.85em;">
                    The file will be named <code>decision-observability-export.html</code>
                </p>
            </div>
        </div>

        <div id="tab-events" class="tab-content" style="display:none">
            <div class="card">
                <h3>Workflow Event Details with Payloads</h3>
                <div class="query-box">-- Query activity inputs, outputs, and workflow payloads
SELECT event_id, event_type, event_time, event_data
FROM events WHERE workflow_id = '...'
ORDER BY event_id

-- event_data contains: activity_input, result, workflow_input, etc.</div>
                <p style="color: var(--text-muted); margin-bottom: 15px;">
                    Select a workflow to view its events with full payload data (activity inputs, outputs, routing decisions).
                    Workflows sorted by most recent first; events sorted chronologically.
                </p>
                <div style="margin-bottom: 18px;">
                    <select id="workflow-select" style="background: var(--card-bg); color: var(--text); border: 2px solid var(--border); padding: 12px 16px; border-radius: 8px; width: 100%; max-width: 450px; font-size: 0.95em; font-family: inherit; cursor: pointer; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--accent)'" onblur="this.style.borderColor='var(--border)'">
                        <option value="">Select a workflow...</option>
                    </select>
                </div>
                <div id="events-results"></div>
            </div>
        </div>

        <div id="tab-activity-context" class="tab-content" style="display:none">
            <div class="card">
                <h3>Activity Decision Context</h3>
                <div style="background: rgba(40, 167, 69, 0.1); border-left: 3px solid var(--success); padding: 12px 16px; border-radius: 0 6px 6px 0; margin-bottom: 20px;">
                    <strong style="color: var(--success)">Direct Activity Writes:</strong>
                    <span style="color: var(--text)">This data is captured directly from activities using <code>xtdb.Save(ctx)</code>.
                    It records the exact external state (churn scores, routing inputs) at the moment each decision was made.</span>
                </div>
                <div class="query-box">-- Query decision context captured directly from activities
SELECT _id, workflow_id, customer_id, churn_score, risk_level, _valid_from
FROM activity_churn_signals
ORDER BY _valid_from DESC

SELECT _id, workflow_id, queue, priority, reason_codes, input_churn_score, input_sentiment
FROM activity_routing_decisions
ORDER BY _valid_from DESC</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h4 style="color: var(--dark); margin-bottom: 12px; font-size: 1em;">Churn Signals Captured</h4>
                        <div id="activity-churn-results" class="loading">Loading churn signals...</div>
                    </div>
                    <div>
                        <h4 style="color: var(--dark); margin-bottom: 12px; font-size: 1em;">Routing Decisions Captured</h4>
                        <div id="activity-routing-results" class="loading">Loading routing decisions...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // Export tab: navigate directly to download
                if (tab.dataset.tab === 'export') {
                    window.location.href = '/api/export';
                    return;
                }
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).style.display = 'block';
            });
        });

        async function loadData() {
            try {
                const [workflows, misrouted, counterfactual, timeline, beforeAfter] = await Promise.all([
                    fetch('/api/workflows').then(r => r.json()),
                    fetch('/api/audit/misrouted').then(r => r.json()),
                    fetch('/api/audit/counterfactual').then(r => r.json()),
                    fetch('/api/timeline').then(r => r.json()),
                    fetch('/api/audit/before-after').then(r => r.json())
                ]);

                document.querySelector('#stat-workflows .stat-value').textContent =
                    workflows ? workflows.length : 0;
                document.querySelector('#stat-misrouted .stat-value').textContent =
                    misrouted.count || 0;
                document.querySelector('#stat-lost-ltv .stat-value').textContent =
                    '$' + (counterfactual.total_lost_ltv || 0).toLocaleString();

                renderMisrouted(misrouted);
                renderCounterfactual(counterfactual);
                renderTimeline(timeline);
                renderBeforeAfter(beforeAfter);
            } catch (err) {
                console.error('Error loading data:', err);
            }
        }

        function renderMisrouted(data) {
            const container = document.getElementById('misrouted-results');
            if (!data.results || data.results.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted)">No misrouted customers found. Run the demo to generate data.</p>';
                return;
            }
            container.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Customer</th>
                            <th>Churn Score</th>
                            <th style="text-align: center">Risk</th>
                            <th>Decision Time</th>
                            <th>Flagged At</th>
                            <th style="text-align: right">Lag</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${data.results.map(r => `
                            <tr>
                                <td><strong>${r.customer_id}</strong></td>
                                <td class="text-mono">${(r.churn_score * 100).toFixed(0)}%</td>
                                <td style="text-align: center"><span class="badge badge-${r.risk_level}">${r.risk_level}</span></td>
                                <td class="text-mono">${new Date(r.decision_time).toLocaleTimeString()}</td>
                                <td class="text-mono text-muted">${new Date(r.churn_flagged_at).toLocaleTimeString()}</td>
                                <td style="text-align: right" class="text-mono"><strong>${formatDuration(r.lag_seconds)}</strong></td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function renderCounterfactual(data) {
            const container = document.getElementById('counterfactual-results');
            if (!data.results || data.results.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted)">No counterfactual data. Load churn predictions and outcomes first.</p>';
                return;
            }
            container.innerHTML = `
                <div class="stat-grid" style="margin-bottom: 20px">
                    <div class="stat danger">
                        <div class="stat-value">${data.churned}</div>
                        <div class="stat-label">Churned</div>
                    </div>
                    <div class="stat success">
                        <div class="stat-value">${data.retained}</div>
                        <div class="stat-label">Retained</div>
                    </div>
                    <div class="stat warning">
                        <div class="stat-value">${Math.round(data.churned / data.high_risk_total * 100)}%</div>
                        <div class="stat-label">Churn Rate</div>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Customer</th>
                            <th>Churn Score</th>
                            <th style="text-align: center">Outcome</th>
                            <th>Reason</th>
                            <th style="text-align: right">LTV</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${data.results.map(r => `
                            <tr>
                                <td><strong>${r.customer_id}</strong></td>
                                <td class="text-mono">${(r.churn_score * 100).toFixed(0)}%</td>
                                <td style="text-align: center"><span class="badge badge-${r.churned ? 'churned' : 'retained'}">${r.churned ? 'Churned' : 'Retained'}</span></td>
                                <td class="text-muted">${r.churn_reason || '—'}</td>
                                <td style="text-align: right" class="text-mono"><strong>$${r.final_ltv.toLocaleString()}</strong></td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function renderTimeline(data) {
            const container = document.getElementById('timeline-results');
            if (!data || data.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted)">No timeline events. Run the demo to generate data.</p>';
                return;
            }
            container.classList.remove('loading');
            container.innerHTML = data.map(e => `
                <div class="timeline-item ${e.source}">
                    <div class="timeline-source">${e.source}</div>
                    <div class="timeline-time">${new Date(e.event_time).toLocaleString()}</div>
                    <div class="timeline-desc"><strong>${e.id}</strong>: ${e.description}</div>
                </div>
            `).join('');
        }

        function renderBeforeAfter(data) {
            const container = document.getElementById('corrections-results');
            if (data.error) {
                container.innerHTML = `<p style="color: var(--warning)">${data.error}</p>`;
                return;
            }

            const before = data.before || { count: 0, results: [] };
            const after = data.after || { count: 0, results: [] };
            const newDet = data.new_detections || { count: 0, results: [] };
            const preTime = data.pre_correction_time || '';

            function renderResultsTable(results) {
                if (!results || results.length === 0) {
                    return '<p style="color: var(--text-muted)">No misrouted customers detected</p>';
                }
                return `<table>
                    <thead><tr>
                        <th>Customer</th><th>Score</th><th style="text-align:center">Risk</th><th>Time</th><th style="text-align:right">Lag</th>
                    </tr></thead>
                    <tbody>${results.map(r => `<tr>
                        <td><strong>${r.customer_id}</strong></td>
                        <td class="text-mono">${(r.churn_score * 100).toFixed(0)}%</td>
                        <td style="text-align:center"><span class="badge badge-${r.risk_level}">${r.risk_level}</span></td>
                        <td class="text-mono">${new Date(r.decision_time).toLocaleTimeString()}</td>
                        <td style="text-align:right" class="text-mono">${formatDuration(r.lag_seconds)}</td>
                    </tr>`).join('')}</tbody>
                </table>`;
            }

            container.innerHTML = `
                <div style="background: rgba(255, 184, 0, 0.15); border-left: 3px solid var(--accent); padding: 12px 16px; border-radius: 0 6px 6px 0; margin-bottom: 20px;">
                    <strong style="color: var(--dark)">How this works:</strong>
                    <span style="color: var(--text)">The "Before" query uses <code>SETTING DEFAULT SYSTEM_TIME AS OF</code> to show what the database believed
                    <em>before</em> model corrections arrived. The "After" query shows current state with corrections incorporated.
                    Same data, same query &mdash; different points in system time.</span>
                </div>

                <p style="color: var(--text-muted); margin-bottom: 15px; font-size: 0.85em;">
                    Pre-correction snapshot: <code>${preTime ? new Date(preTime).toLocaleString() : 'N/A'}</code>
                </p>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div style="background: var(--card-bg); border-radius: 6px; padding: 15px; border: 1px solid var(--border);">
                        <h3 style="color: var(--text-muted); font-size: 0.95em; margin-bottom: 10px; font-weight: 600;">
                            Before Corrections
                            <span class="badge" style="background: var(--bg); border: 1px solid var(--border); color: var(--text-muted); margin-left: 8px;">${before.count} misrouted</span>
                        </h3>
                        ${renderResultsTable(before.results)}
                    </div>
                    <div style="background: var(--card-bg); border-radius: 6px; padding: 15px; border: 1px solid var(--border);">
                        <h3 style="color: var(--dark); font-size: 0.95em; margin-bottom: 10px; font-weight: 600;">
                            After Corrections
                            <span class="badge" style="background: rgba(255, 184, 0, 0.2); color: var(--dark); margin-left: 8px;">${after.count} misrouted</span>
                        </h3>
                        ${renderResultsTable(after.results)}
                    </div>
                </div>

                ${newDet.count > 0 ? `
                <div style="background: rgba(220, 53, 69, 0.08); border: 1px solid rgba(220, 53, 69, 0.3); border-radius: 6px; padding: 15px;">
                    <h3 style="color: var(--danger); font-size: 0.95em; margin-bottom: 10px; font-weight: 600;">
                        Newly Detected Misrouted Customers
                        <span class="badge badge-high" style="margin-left: 8px;">+${newDet.count} found</span>
                    </h3>
                    <p style="color: var(--text-muted); font-size: 0.85em; margin-bottom: 10px;">
                        These customers were only identified as misrouted <em>after</em> the model corrections arrived.
                        Without bitemporal tracking, the original "before" state would be lost.
                    </p>
                    ${renderResultsTable(newDet.results)}
                </div>` : ''}

                <div style="margin-top: 15px; padding: 12px 16px; background: rgba(40, 167, 69, 0.08); border-left: 3px solid var(--success); border-radius: 0 6px 6px 0;">
                    <strong style="color: var(--success)">Key insight:</strong>
                    <span style="color: var(--text)">In a traditional database, the corrections would overwrite the original scores.
                    You'd never know that these ${newDet.count} customers were <em>invisible</em> to the audit before corrections.
                    XTDB's system-time travel preserves both views.</span>
                </div>
            `;
        }

        // Format seconds into human-readable duration
        function formatDuration(seconds) {
            const absSeconds = Math.abs(seconds);
            if (absSeconds < 60) return `${Math.round(absSeconds)}s`;
            if (absSeconds < 3600) return `${Math.round(absSeconds / 60)}m`;
            if (absSeconds < 86400) {
                const hours = Math.floor(absSeconds / 3600);
                const mins = Math.round((absSeconds % 3600) / 60);
                return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
            }
            const days = Math.floor(absSeconds / 86400);
            const hours = Math.round((absSeconds % 86400) / 3600);
            return hours > 0 ? `${days}d ${hours}h` : `${days}d`;
        }

        loadData();
        setInterval(loadData, 5000);

        // Workflow events tab functionality
        async function loadWorkflowOptions() {
            try {
                const workflows = await fetch('/api/workflows').then(r => r.json());
                const select = document.getElementById('workflow-select');
                select.innerHTML = '<option value="">Select a workflow...</option>';
                if (workflows) {
                    workflows.forEach(wf => {
                        const opt = document.createElement('option');
                        opt.value = wf.workflow_id;
                        opt.textContent = `${wf.workflow_id} (${wf.status})`;
                        select.appendChild(opt);
                    });
                }
            } catch (err) {
                console.error('Error loading workflows:', err);
            }
        }

        document.getElementById('workflow-select').addEventListener('change', async (e) => {
            const workflowId = e.target.value;
            const container = document.getElementById('events-results');
            if (!workflowId) {
                container.innerHTML = '';
                return;
            }
            container.innerHTML = '<div class="loading">Loading events...</div>';
            try {
                const events = await fetch(`/api/events/${encodeURIComponent(workflowId)}`).then(r => r.json());
                renderWorkflowEvents(events);
            } catch (err) {
                container.innerHTML = `<p style="color: var(--danger)">Error: ${err.message}</p>`;
            }
        });

        function renderWorkflowEvents(events) {
            const container = document.getElementById('events-results');
            if (!events || events.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted)">No events found for this workflow.</p>';
                return;
            }

            const eventTypeColors = {
                'WorkflowExecutionStarted': 'var(--success)',
                'WorkflowExecutionCompleted': 'var(--success)',
                'ActivityTaskScheduled': 'var(--accent-hover)',
                'ActivityTaskStarted': 'var(--accent-hover)',
                'ActivityTaskCompleted': 'var(--accent-hover)',
                'WorkflowTaskScheduled': 'var(--text-muted)',
                'WorkflowTaskStarted': 'var(--text-muted)',
                'WorkflowTaskCompleted': 'var(--text-muted)',
            };

            container.innerHTML = events.map((evt, idx) => {
                const hasData = evt.event_data && Object.keys(evt.event_data).length > 0;
                const color = eventTypeColors[evt.event_type] || 'var(--text)';
                const dataJson = hasData ? JSON.stringify(evt.event_data, null, 2) : null;

                return `
                    <div style="border: 1px solid var(--border); border-radius: 6px; margin-bottom: 10px; overflow: hidden; background: var(--card-bg);">
                        <div style="display: flex; align-items: center; gap: 12px; padding: 12px 15px; background: var(--bg); cursor: ${hasData ? 'pointer' : 'default'};"
                             ${hasData ? `onclick="toggleEventData('event-data-${idx}')"` : ''}>
                            <span style="color: var(--text-muted); font-size: 0.85em; min-width: 30px; font-weight: 600;">#${evt.event_id}</span>
                            <span style="color: ${color}; font-weight: 600;">${evt.event_type}</span>
                            <span style="color: var(--text-muted); font-size: 0.85em; margin-left: auto;">
                                ${new Date(evt.event_time).toLocaleTimeString()}
                            </span>
                            ${hasData ? `<span style="color: var(--dark); font-size: 0.75em; padding: 3px 10px; background: var(--accent); border-radius: 10px; font-weight: 600;">payload</span>` : ''}
                        </div>
                        ${hasData ? `
                            <div id="event-data-${idx}" style="display: none; padding: 15px; background: #2c2f32; border-top: 1px solid var(--border);">
                                <pre style="margin: 0; font-size: 0.8em; color: #e0e0e0; white-space: pre-wrap; word-break: break-all;">${escapeHtml(dataJson)}</pre>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        function toggleEventData(id) {
            const el = document.getElementById(id);
            if (el) {
                el.style.display = el.style.display === 'none' ? 'block' : 'none';
            }
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Load workflow options when events tab is shown
        document.querySelector('[data-tab="events"]').addEventListener('click', loadWorkflowOptions);

        // Activity Context tab functionality
        async function loadActivityContext() {
            try {
                const [churnSignals, routingDecisions] = await Promise.all([
                    fetch('/api/activity/churn-signals').then(r => r.json()),
                    fetch('/api/activity/routing-decisions').then(r => r.json())
                ]);
                renderChurnSignals(churnSignals);
                renderRoutingDecisions(routingDecisions);
            } catch (err) {
                console.error('Error loading activity context:', err);
                document.getElementById('activity-churn-results').innerHTML =
                    '<p style="color: var(--text-muted)">Could not load churn signals. Ensure XTDB_CONN_STRING is configured for the worker.</p>';
                document.getElementById('activity-routing-results').innerHTML =
                    '<p style="color: var(--text-muted)">Could not load routing decisions. Ensure XTDB_CONN_STRING is configured for the worker.</p>';
            }
        }

        function renderChurnSignals(data) {
            const container = document.getElementById('activity-churn-results');
            if (!data || data.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted)">No churn signals captured yet. Run workflows with XTDB_CONN_STRING configured.</p>';
                return;
            }
            container.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Customer</th>
                            <th>Score</th>
                            <th style="text-align: center">Risk</th>
                            <th>Workflow</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${data.slice(0, 10).map(r => `
                            <tr>
                                <td><strong>${r.customer_id || '-'}</strong></td>
                                <td class="text-mono">${r.churn_score ? (r.churn_score * 100).toFixed(0) + '%' : '-'}</td>
                                <td style="text-align: center"><span class="badge badge-${r.risk_level || 'low'}">${r.risk_level || '-'}</span></td>
                                <td class="text-mono text-muted" style="font-size: 0.8em;">${(r.workflow_id || '').substring(0, 20)}...</td>
                                <td class="text-mono text-muted">${r.valid_from ? new Date(r.valid_from).toLocaleTimeString() : '-'}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                ${data.length > 10 ? `<p style="color: var(--text-muted); font-size: 0.85em; margin-top: 10px;">Showing 10 of ${data.length} records</p>` : ''}
            `;
        }

        function renderRoutingDecisions(data) {
            const container = document.getElementById('activity-routing-results');
            if (!data || data.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted)">No routing decisions captured yet. Run workflows with XTDB_CONN_STRING configured.</p>';
                return;
            }
            container.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Queue</th>
                            <th style="text-align: center">Priority</th>
                            <th>Reasons</th>
                            <th>Churn</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${data.slice(0, 10).map(r => `
                            <tr>
                                <td><strong>${r.queue || '-'}</strong></td>
                                <td style="text-align: center" class="text-mono">${r.priority || '-'}</td>
                                <td class="text-muted" style="font-size: 0.85em;">${r.reason_codes || '-'}</td>
                                <td class="text-mono">${r.input_churn_score ? (r.input_churn_score * 100).toFixed(0) + '%' : '-'}</td>
                                <td class="text-mono text-muted">${r.valid_from ? new Date(r.valid_from).toLocaleTimeString() : '-'}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                ${data.length > 10 ? `<p style="color: var(--text-muted); font-size: 0.85em; margin-top: 10px;">Showing 10 of ${data.length} records</p>` : ''}
            `;
        }

        // Load activity context when tab is shown
        document.querySelector('[data-tab="activity-context"]').addEventListener('click', loadActivityContext);

        // Demo script toggle
        function toggleScript() {
            const overlay = document.getElementById('scriptOverlay');
            overlay.classList.toggle('visible');
        }

        // Keyboard shortcut 's' to toggle script
        document.addEventListener('keydown', (e) => {
            if (e.key === 's' || e.key === 'S') {
                // Don't trigger if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                e.preventDefault();
                toggleScript();
            }
            // Escape to close
            if (e.key === 'Escape') {
                document.getElementById('scriptOverlay').classList.remove('visible');
            }
        });

        // Smooth scroll for TOC links
        document.querySelectorAll('.script-toc a').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const target = document.querySelector(link.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    </script>
</body>
</html>
